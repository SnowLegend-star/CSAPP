第 3 章 程序的机器级表示

超线程（hyperthreading）：在一个处理器上同时运行两个程序。
        p104

IA32（Intel Architecture 32-bit）：Intel 32位体系结构
        p104

计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。对于机
器级编程来说，其中两种抽象尤为重要。

第一种是机器级程序的格式和行为，定义为指令集体系结构（Instruction set
architecture, ISA），它定义了处理器状态、指令的格式，以及每条指令对状态的影响。

第二种抽象是，机器级程序使用的存储器地址是虚拟地址，提供的存储器模型看上去是一个
非常大的字节数组。
        p106

虽然 C 语言提供了一种模型，可以在存储器中声明和分配各种数据类型的对象，但是机器
代码只是简单地将存储器看成是一个很大的、按字节寻址的数组。C 语言中的聚合数据类型，
例如数组和结构，在机器代码中用连续的一组字节来表示。即使是标量数据类型，汇编代码
也不区分有符号或无符号整数，不区分各种类型的指针，甚至不区分指针和整数。
        p106~p107

(gdb) x/17xb sum

这条命令告诉 GDB 检查（简写为“x”）17 个十六进制格式（也简写为“x”）的字节（简
写为“b”）。
        p108

unix> gcc -O1 -S -masm=intel code.c
        p110

由于是从 16 位体系结构扩展成 32 位的，Intel 用术语“字”（word）表示 16 位数据类型。
因此，称 32 位数为“双字”（double words），称 64 位数位“四字”（quad words）。我们
后面遇到的大多数指令都是对字节或双字操作的。
        p111

大多数指令有一个或多个操作数（operand），指示出执行一个操作中要引用的源数据值，以
及放置结果的目标位置。IA32 支持多种操作数格式。源数据值可以以常数形式给出，或是从
寄存器或存储器中读出。结果可以存放在寄存器或存储器中。因此，各种不同的操作数的可
能性被分为三种类型。

第一种类型是立即数（immediate），也就是常数值。第二种类型是寄存器（register），它
表示某个寄存器的内容。第三种操作数是存储器（memory）引用，它会根据计算出来的地址
（通常称为有效地址）访问某个存储器位置。
        p112~p113

mov 类中的指令将源操作数的值复制到目的操作数中。源操作数指定的值是一个立即数，存
储在寄存器中或者存储器中。目的操作数指定一个位置，要么是一个寄存器，要么是一个存
储器地址。IA32 加了一条限制，传送指令的两个操作数不能都指向存储器位置。
        p114

C 语言中所谓的“指针”其实就是地址，局部变量通常是保存在寄存器中，而不是在存储器
中。寄存器访问比存储器访问要快得多。
        p117

机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果
来改变控制流或者数据流。

数据相关的控制流是实现有条件行为的更通用和更常见的方法。
        p123

除了整数寄存器，CPU 还维护着一组单个位的条件码（condition code）寄存器，它们描述
了最近的算术或逻辑操作的属性。

CF: 进位标志。最近的操作使最高位产生了进位。可以用来检查无符号操作数的溢出。
ZF: 零标志。最近的操作得出的结果为 0。
SF: 符号标志。最近的操作得到的结果为负数。
OF: 溢出标志。最近的操作数导致一个补码溢出--正溢出或负溢出。
        p124

条件码通常不会直接读取，常用的使用方法有三种：
1. 可以根据条件码的某个组合，将一个字节设置为 0 或者 1
2. 可以条件跳转到程序的某个其他的部分
3. 可以有条件地传送数据
        p125

在产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将跳转目标（目的指令的
地址）编码为跳转指令的一部分。
        p127

jmp 指令是无条件跳转，它可以是直接跳转，即跳转目标是作为指令的一部分编码的；也可
以是间接跳转，即跳转目标是从寄存器或存储器位置中读出的。

在 ATT 汇编语言中，直接跳转是给出一个标号作为跳转目标的，例如：标号“.L1”。间接跳
转的写法是“*”后面跟一个操作数指示符，例如：“jmp *%eax”。
        p127

理解跳转指令的目标如何编码，对研究链接非常重要。
        p127

跳转指令有几种不同的编码，但是最常用的都是 PC（Program Counter）相关的
（PC-relative）。它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的
差作为编码。
        p127

当执行与 PC 相关的寻址时，程序计数器的值是跳转指令后面的那条指令的地址，而不是跳
转指令本身的地址。这种惯例可以追溯到早期实现，当时的处理器会将更新程序计数器作为
执行一条指令的第一步。
        p129

C 语言中三种形式的所有循环 -- do-while、while 和 for -- 都可以用一种简单的策略来
翻译，产生包含一个或多个条件分支的代码。控制的条件转移为循环翻译成机器代码提供了
基本机制。
        p138

数据的条件转移是一种替代的策略。这种方法先计算一个条件操作的两种结果，然后再根据
条件是否满足从而选取一个。只有在一些受限制的情况下，这种策略才可行，但是如果可行，
就可以用一条简单的条件传送指令来实现它。条件传送指令更好地匹配了现代处理器的性能
特性。
        p139

从 1995 年的 PentiumPro 开始，近代 IA32 处理器都拥有条件传送指令，这些指令会根据
条件码的值，选择要么什么都不做，要么将一个值复制到一个寄存器。
        p140

基于条件数据传送的代码比基于条件控制转移的代码性能好，其中的原因，是因为现代处理
器通过使用流水线（pipelining）来获得高性能。

在流水线中，一条指令的处理要经过一系列的阶段，每个阶段执行所需要操作的一小部分。
这种方法通过重叠连续指令的步骤来获得高性能。例如，在取一条指令的时候，执行它前面
一条指令的算术运算。要做到这一点，要求能够事先确定要执行指令的序列，这样才能保持
流水线中充满了待执行的指令。

错误预测一个跳转要求处理器丢掉它为该跳转后所有指令已经做了的工作，然后再开始用从
正确位置处起始的指令区填充流水线。这样一个错误预测会招致很严重的惩罚。大约 20~40
时钟周期的浪费，导致程序性能的严重下降。
        p141

T_arg(p) = (1-p)*T_ok + p*(T_ok+T_mp) = T_ok + p*T_mp
        p141

使用条件传送也不是总会改进代码的效率。编译器必须考虑浪费的计算和由于分支预测错误
所造成的性能处罚之间的相对性能。说实话，编译器并不具有足够的信息来做出可靠的决定。
        p141

总的来说，条件数据传送提供了一种用条件控制转移来实现条件操作的替代策略。它们只能
用于很受限制的情况，但是这些情况还是相当常见的，而且充分利用了现代处理器的运行方
式。
        p141

跳转表是一个数组，表项 i 是一个代码段的地址，这个代码段实现当开关索引值等于 i 时
程序应该采取的动作。程序代码用开关索引值来执行一个跳转表内的数组引用，确定跳转指
令的目标。

和使用一组很长的 if-else 语句相比，使用跳转表的优点是执行开关语句的时间与开关情
况的数量无关。
        p144

执行 switch 语句的关键步骤是通过跳转表来访问代码位置。
        p146

跳转表是一种非常高效的实现多重分支的方法。
        p147

动态的数组分配版本必须用乘法指令对 i 伸展 n 倍，而不能用一系列的移位和加法。
        p163

寄存器溢出（register spiling）：没有足够多的寄存器来保存需要的临时数据，因此编译
器必须把一些局部变量放在存储器中。
        p164

编译器维护关于每个结构类型的信息，指示每个字段（field）的字节偏移。它以这些偏移
作为存储器引用指令的位移，从而产生对结构元素的引用。
        p164

许多计算机系统对基本数据类型合法地址做出了一些限制，要求某种类型对象的地址必须是
某个值 K（通常是 2、4 或 8）的倍数。这种对齐限制简化了形成处理器和存储器系统之间
接口的硬件设计。
        p170

对于大多数 IA32 指令来说，保持数据对齐能够提高效率，但是它不会影响程序的行为。

另一方面，如果数据未对齐，有些实现多媒体操作的 SSE 指令就无法正确地工作。这些指
令对 16 字节数据块进行操作，在 SSE 单元和存储器之间传送数据的指令要求存储器地址
必须是 16 的倍数。任何视图以不满足对齐要求的地址来访问存储器都会导致异常
（exception），默认的行为是程序终止。

因此，IA32 的一个惯例是，确保每个栈帧的长度都是 16 字节的整数倍。编译器就可以在
栈帧中以每个块的存储都是 16 字节对齐的方式来分配存储。
        p170~p171

确保每种数据类型都按照指定方式来组织和分配，即每种类型的对象都满足它的对齐限制，
就可保证实施对齐。
        p171

今天使用的 IA32 格式中的大部分是在 1985 年随着 i386 微处理器的出现所定义的，当时
是将原来 8086 的 16 位指令集扩展到了 32 位。虽然后续的处理器系列引入了新的指令类
型和格式，但是为了保持向后兼容性，许多编译器，包括 GCC，都避免使用这些特性。

条件传送指令，是 Intel 在 1995 年引入的，比起更传统的条件分支，能够产生显著的性
能提升，但是在大多数的 GCC 配置中，都不会产生这样的指令。
        p183

4GHz 时钟，每秒运行大约 50 亿条指令。
        p184

基于微处理器的系统已经变得很普遍。即使今天的超级计算机也是基于利用许多微处理器并
行计算的能力。
        p184

x86-64 是 Intel 指令集到 64 位的一个演化。它保持了与 IA32 完全的后向兼容性，并且
又增加了新的数据格式，以及其他一些特性，使得能力更强，性能更高。
        p185

在编译器方面，GCC 的开发者坚定地保持与 i386 的二进制兼容性，即使是 IA32 指令集中
添加了有用的特性，包括条件传送和更现代的浮点指令集。只有以特殊的命令行选项设置编
译时，才会使用这些特性。
        p185

x86-64 与 IA32 的一些区别：

    o 寄存器的数量翻倍至 16 个
    o 所有的寄存器都是 64 位长。IA32 寄存器的 64 位扩展分别为 %rax、%rcx、%rdx、
      %rbx、%rsi、%rdi、%rsp 和 %rbp。新增加的寄存器命名为 %r8~%r15。
    o 可以直接访问每个寄存器的低 32 位。这就给了我们 IA32 中熟悉的那些寄存器：
      %eax、%ecx、%edx、%ebx、%esi、%edi、%esp和 %ebp，以及 8 个新 32 位寄存器：
      %r8d~%r15d。
    o 可以直接访问每个寄存器的低 16 位。新寄存器的字大小版本命名为 %r8w~%r15w。
    o 可以直接访问每个寄存器的低 8 位。新寄存器的字节大小版本命名为 %r8b~%r15b。
    o 为了后向兼容性，具有单字节操作数的指令可以直接访问 %rax、%rcx、%rdx 和
      %rbx 的第二个字节

寄存器 %rsp 有特殊的状态，它会保存指向栈顶元素的指针。与 IA32 不同的是，没有帧指
针寄存器；可以用寄存器 %rbp 作为通用寄存器。

此外，有一些算术指令对寄存器 %rax 和 %rdx 有特殊的用法。
        p188~p189

ATT 格式指令 cqto 在 Intel 和 AMD 文档中被称为 cqo。
ATT 格式指令 cltq 在 Intel 和 AMD 文档中被称为 cdqe。

cltq: 将 %eax 转换成四字
cqto: 转换成八字
        p192

x86-64 最多可以有 6 个整型（整数和指针）参数可以通过寄存器进行传递。寄存器按照指
定的顺序来使用，使用的寄存器名对应于所传递的数据的大小

|----+------+------+------+------+------+------|
|    | 1    | 2    | 3    | 4    | 5    | 6    |
|----+------+------+------+------+------+------|
| 64 | %rdi | %rsi | %rdx | %rcx | %r8  | %r9  |
| 32 | %edi | %esi | %edx | %ecx | %r8d | %r9d |
| 16 | %di  | %si  | %dx  | %cx  | %r8w | %r9w |
|  8 | %dil | %sil | %dl  | %cl  | %r8b | %r9b |
|----+------+------+------+------+------+------|
        p195

如果所有的局部变量都能保存在寄存器中，而且这个函数也不会调用其他函数（参考过程调
用的树结构，有时称之为叶子过程（leaf procedure）），那么需要栈的唯一原因就是用来
保存返回地址。
        p196

另一方面，使得函数可能需要栈帧的原因如下：
    o 局部变量太多，不能都放在寄存器中
    o 有些局部变量是数组或者结构
    o 函数用取地址操作符（&）来计算一个局部变量的地址
    o 函数必须将栈上的某些参数传递到另一个函数
    o 在修改一个被调用者保存寄存器之前，函数需要保存它的状态
        p196

x86-64 过程的栈帧通常有固定的大小，在过程开始时通过减小栈指针（寄存器 %rsp）来设
置。在调用过程中，栈指针保持在固定的位置，使得可以用相对于栈指针的偏移量来访问数
据。因此，就不再需要 IA32 代码中可见的帧指针（寄存器 %ebp）了。
        p196

每当一个函数（调用者）要调用另一个函数（被调用者）时，返回地址会被压入栈中。通常，
我们认为这是调用者栈帧的一部分，它编码的是某种调用者的状态。但是，当控制返回到调
用者时，会把这个信息从栈中弹出来，所以它不会影响调用者访问栈帧中值所使用的偏移量。
        p196

寄存器保存惯例：

调用者保存：函数可以自由地覆盖这些寄存器的值；
被调用者保存：函数在写这些寄存器之前，必须在栈上保存它们的值

在 x86-64 中，指定为被调用者保存的寄存器有：

    o %rbx
    o %rbp
    o %r12
    o %r13
    o %r14
    o %r15
        p197

在 x86-64 的 16 个通用目的寄存器中，我们看到有 6 个是用来传递参数，6 个是由被调
用者保存的临时寄存器，1 个（%rax）保存函数的返回值，还有 1 个（%rsp）作为栈指针，
只剩下 %r10 和 %r11 是作为调用者保存的临时寄存器。当然，当参数少于 6 个或者当函
数用完了参数参数时，就可以使用参数寄存器了，而在产生处最终的结果之前，%rax 可以
重复利用。
        p198

x86-64 的一个不同寻常的特性是能够访问栈指针之外的存储器。它要求虚拟存储器管理系
统为这段区域分配存储器。x86-64 ABI 指明程序可以使用当前栈指针之外 128 字节的范围
（即低于当前栈指针的值）。ABI 将这个区域称为红色地带（red zone）。必须保持当栈指
针移动时，红色地带可读可写。
        p199

x86-64 遵循一组更严格的对齐要求。对于任何需要 K 字节的标量数据类型来说，它的起始
地址必须是 K 的倍数。
        p200

将 x86 处理器带入新纪元的功臣是 AMD 和 GCC 的作者。x86-64 硬件和编程规则的形成改
变了处理器，过去它严重依赖于栈来保存程序的状态，现在则是将最常使用的状态部分保存
在更快并扩展了的寄存器组中。x86 终于赶上了 20 世纪 80 年代早期 RISC 处理器提出的
理念！

既能运行 IA32 代码又能运行 x86-64 代码的处理器变得越来越常见。现在许多桌面电脑和
笔记本系统都还是运行着它们操作系统的 32 位版本，这也限制了这些机器只能运行 32 位
应用。运行 64 位操作系统的机器，由于其能够运行 32 位和 64 位应用，已经成为高端机
器的普遍选择，例如，数据库服务器和科学计算。将应用从 32 位转换成 64 位最大的缺陷
是指针变量的大小翻倍了，由于许多数据结构都包含指针，这也意味着总的存储器需求也几
乎翻倍了。只有对内存需求超过 IA32 的 4GB 地址空间限制的应用才执行这种 32 位到 64
位的转换。历史表明应用总是能变得充分使用所有可得的处理能力和存储器大小，因此我们
可以很放心地预测，运行 64 位操作系统和应用的 64 位处理器会逐渐变得更普遍。
        p200~p201

我们把存储模型、指令和传递规则的组合称为机器的浮点体系结构。
        p201

由于 x86 处理器有很长的发展演变历史，它提供了多种浮点体系结构，目前有两种还在使
用。第一种，称为“x87”，可以追溯到早期的 Intel 微处理器，直到现在都还是标准的实
现。第二种，称为“SSE”，是基于较新的对 x86 处理器增加多媒体应用的支持。
        p201

在原来的 Intel 机器中，浮点计算是由一个独立的协处理器完成的。

协处理器是一个具有自己的寄存器和执行一组指令的处理能力的单元。这个协处理器用一个
独立的芯片实现，称为 8087、80287 和 i387，分别同处理芯片 8086、80286 和 i386 配
套，因而俗称“x87”。
        p201
