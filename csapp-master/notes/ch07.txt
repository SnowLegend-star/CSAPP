第 7 章 链接

链接（linking）是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个
文件可被加载（或被拷贝）到存储器并执行。

链接可以执行于编译时（compile time），也就是在源代码被翻译成机器代码时；也可以执
行于加载时（load time），也就是在程序被加载器（loader）加载到存储器并执行时；甚
至执行于运行时（run time），由应用程序来执行。

在早期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做链接器（linker）
的程序自动执行的。
        p448

链接器在软件开发中扮演着一个关键的角色，因为它们使得分离编译（separate
compilation）成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是
可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些
模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。
        p448

为什么要这么麻烦地学习关于链接的知识呢？

    o 理解链接器将帮助你构造大型程序

      构造大型程序的程序员经常会遇到由于缺少模块、缺少库或者不兼容的库版本引起的
      链接器错误。除非你理解链接器是如何解析引用、什么是库以及链接器是如何使用库
      来解析引用的，否则这类错误将令你感到迷惑和挫败。

    o 理解链接器将帮助你避免一些危险的编程错误

      UNIX 链接器解析符号引用时所做的决定可以不动声色地影响你程序的正确性。在默
      认情况下，错误地定义多个全局变量的程序将通过链接器，而不产生任何警告信息。
      由此得到的程序会产生令人迷惑的运行时行为，而且非常难以调试。我们将向你展示
      这是如何发生的，以及该如何避免它。

    o 理解链接器将帮助你理解语言的作用域规则是如何实现的

      例如，全局和局部变量之间的区别是什么？当你定义一个具有 static 属性的变量或
      函数时，到底实际意味着什么？

    o 理解链接器将帮助你理解其他重要的系统概念

      链接器产生的可执行目标文件在重要的系统功能中扮演着关键角色，比如加载和运行
      程序、虚拟存储器、分页和存储器映射。

    o 理解链接器将使你能够利用共享库

      多年以来，链接都被认为是相当简单和无趣的。然而，随着共享库和动态链接在现代
      操作系统中重要性的日益加强，链接成为一个复杂的过程，它为知识丰富的程序员提
      供了强大的能力。比如，许多软件产品在运行时使用共享库来升级压缩包装的
      （shrink-wrapped）二进制程序。还有，大多数 Web 服务器都依赖于共享库的动态
      链接来提供动态内容。
        p448

无论是什么样的操作系统、ISA 或者目标文件格式，基本的链接概念是通用的，认识到这一
点是很重要的。
        p448

大多数编译系统提供编译驱动程序（compiler driver），它代表用户在需要时调用语言处
理器、编译器、汇编器和链接器。比如，要用 GNU 编译系统构造示例程序，我们就要通过
在外壳中输入下列命令行来调用 GCC 驱动程序：

    unix> gcc -O2 -g -o p main.c swap.c

驱动程序在将示例程序从 ASCII 码源文件翻译成可执行目标文件时的行为：

1. 运行 C 预处理其（cpp），将 C 源程序 main.c 翻译成一个 ASCII 码的中间文件 main.i

    unix> cpp [other arguments] main.c /tmp/main.i

2. 运行 C 编译器（cc1），它将 main.i 翻译成一个 ASCII 汇编语言文件 main.s

    unix> cc1 /tmp/main.c -O2 [other arguments] -o /tmp/main.s

3. 运行汇编器（as），它将 main.s 翻译成一个可重定位目标文件（relocatable object file）main.o:

    unix> as [other arguments] -o /tmp/main.o /tmp/main.s

4. 运行链接器 ld，将 main.o 和 swap.o（驱动程序经过相同的过程生成 swap.o） 以及一
   些必要的系统目标文件组合起来，创建一个可执行目标文件（executable object file）
   p：

    unix> ld -o p [system object files and args] /tmp/main.o /tmp/swap.o
        p449~p450

要运行可执行文件 p，我们在 UNIX 外壳的命令行上输入它的名字：

    unix> ./p

外壳调用操作系统中一个叫做加载器的函数，它拷贝可执行文件 p 中的代码和数据到存储
器，然后将控制转移到这个程序的开头。
        p450

像 UNIX ld 程序这样的静态链接器（static linker）以一组可重定位目标文件和命令行参
数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。

输入的可重定位目标文件由各种不同的代码和数据节（section）组成。指令在一个节中，
初始化的全局变量在另一个节中，而未初始化的变量又在另外一个节中。
        p450

为了构造可执行文件，链接器必须完成两个主要任务：

    o 符号解析（symbol resolution）

      目标文件定义和引用符号。符号解析的目的是将每个符号引用刚好和一个符号定义联
      系起来

    o 重定位（relocation）

      编译器和汇编器生成从地址 0 开始的代码和数据节。链接器通过把每个符号定义与
      一个存储器位置联系起来，然后修改所有对这些符号的引用，使得他们指向这个存储
      器位置，从而重定位这些节

要记住关于链接器的一些基本事实：目标文件纯粹是字节块的集合。

这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包含知道链接器和加载器
的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据
块中的各种位置。

链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。
        p450

目标文件有三种形式：

    o 可重定位目标文件

      包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创
      建一个可执行目标文件

    o 可执行目标文件

      包含二进制代码和数据，其形式可以被直接拷贝到存储器并执行

    o 共享目标文件

      一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载到存储器并
      链接
        p450

编译器和汇编器生成可重定位目标文件（包括共享目标文件）。链接器生成可执行目标文件。
从技术上来说，一个目标模块（objcet module）就是一个字节序列，而一个目标文件
（object file）就是一个存放在磁盘文件中的目标模块。
        p450

ELF头（ELF header）以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的
大小和字节顺序。

ELF头 剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括 ELF头 的大小、
目标文件的类型（如可重定位、可执行或者是共享的）、机器类型（如 IA32）、节头部表
（section header table）的文件偏移，以及节头部表中的条目大小和数量。

不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目
（entry）。夹在 ELF头 和节头部表之间的都是节。
        p451

每个可重定位目标模块 m 都有一个符号表，它包含 m 所定义和引用的符号的信息。在链接
器的上下文中，有三种不同的符号：

    o 全局符号（global）

      由 m 定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的 C 函数
      以及被定义为不带 C static 属性的全局变量

    o 外部符号(external)

      由其他模块定义并被模块 m 引用的全局符号。这些符号称为外部符号，应对与定义
      在其他模块中的 C 函数和变量

    o 本地符号（local）

      只被模块 m 定义和引用的本地符号。有的本地链接器符号对应与带 static 属性的
      C 函数和全局变量。这些符号在模块 m 中随处可见，但是不能被其他模块引用。目
      标文件中对应于模块 m 的节和相应的源文件的名字也能获得本地符号
        p452

认识到本地链接器符号和本地程序变量的不同是很重要的。.symtab 中的符号表不包含对应
于本地非静态程序变量的任何符号。这些符号在运行时在栈中被管理，链接器对此类符号不
感兴趣。
        p452

有趣的是，定义为带有 C static 属性的本地过程变量是不在栈中管理的。相反，编译器在
.data 和 .bss 中为每个定义分配空间，并在符号表中创建一个有唯一名字的本地链接器符
号。
        p452

符号表是由汇编器构造的，使用编译器输出到汇编语言 .s 文件的符号。.symtab 节中包含
ELF 符号表。这张符号表包含一个条目的数组。
        p453

每个符号都和目标文件的某个节相关联，由 section 字段表示，该字段也是一个到节头部
表的索引。有三个特殊的伪节（pseudo section），他们在节头部表中是没有条目的：

    o ABS

      代表不该被重定位的符号

    o UNDEF

      代表未定义的符号，也就是在本目标模块中引用，但是却在其他地方定义的符号

    o COMMON

      表示还未被分配位置的未初始化的数据目标
        p453

链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确
定的符号定义联系起来。
        p454

对 C++ 和 Java 中链接器符号的毁坏（mangling）

C++ 和 Java 都允许重载方法，这些方法在源代码中有相同的名字，却有不同的参数列表。
那么链接器是如何区别这些不同的重载函数之间的差异呢？C++ 和 Java 中能使用重载函数，
是因为编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字。

这种编码过程叫做毁坏（mangling），而相反的过程叫做恢复（demangling）。

幸运的是，C++ 和 Java 使用兼容的毁坏策略。一个被毁坏的类名字是由名字中字符的整数
数量，后面跟原始名字组成的。比如，类 Foo 被编码成 3Foo。方法被编码为原始方法名，
后面加上 __，加上被毁坏的类名，再加上每个参数的单个字母编码。比如，Foo::bar(int,
long)被编码为 bar__3Fooil。毁坏全局变量和模板名字的策略是相似的。
        p454~p455

实际上，所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，
称为静态库（static library）。它可以用作链接器的输入。当链接器构造一个输出的可执
行文件时，它只拷贝静态库里被应用程序引用的目标模块。
        p457

在 UNIX 系统中，静态库以一种称为存档（archive）的特殊文件格式存放在磁盘中。存档
文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的
大小和位置。存档文件名由后缀 .a 标识。
        p458

在符号解析的阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的相同顺序来
扫描可重定位目标文件和存档文件。

在这次扫描中，链接器维持一个可重定位目标文件的集合 E（这个集合中的文件会被合并起
来形成可执行文件），一个未解析的符号（即引用了但是尚未定义的符号）集合 U，以及一
个在前面输入文件中已定义的符号集合 D。

初始时，E、U、D 都是空的。

    o 对于命令行上的每个输入文件 f，链接器会判断 f 是一个目标文件还是一个存档文
      件。如果 f 是一个目标文件，那么链接器把 f 添加到 E，修改 U 和 D 来反映 f
      中的符号定义和引用，并继续下一个输入文件。

    o 如果 f 是一个存档文件，那么链接器就尝试匹配 U 中未解析的符号和由存档文件成
      员定义的符号。如果某个存档文件成员 m，定义了一个符号来解析 U 中的一个引用，
      那么就将 m 加到 E 中，并且链接器修改 U 和 D 来反映 m 中的符号定义和引用。
      对存档文件中所有的成员目标文件都反复进行这个过程，直到 U 和 D 都不再发生变
      化。在此时，任何不包含在 E 中的成员目标文件都简单地被丢弃，而链接器将继续
      处理下一个输入文件。

    o 如果当链接器完成对命令行上输入文件的扫描后，U 是非空的，那么链接器就会输出
      一个错误并终止。否则，它会合并和重定位 E 中的目标文件，从而构建输出的可执
      行文件

不幸的是，这种算法会导致一些令人困扰的链接时错误，因为命令行上的库和目标文件的顺
序非常重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那
么引用就不能被解析，链接会失败。
        p460

关于库的一般准则是将它们放在命令行的结尾。
        p460

一旦链接器完成了符号解析这一步，它就把代码中的每个符号引用和确定的一个符号定义
（即它的一个输入目标模块中的一个符号表条目）联系起来。在此时，链接器就知道它的输
入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位了，在这个步骤中，将
合并输入模块，并为每个符号分配运行时地址。

重定位由两步组成：

    o 重定位节和符号定义

      在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自
      输入模块的 .data 节被全部合并成一个节，这个节成为输出的可执行目标文件的
      .data 节。然后，链接器将运行时存储器地址赋给新的聚合节，赋给输入模块定义的
      每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每个指令和
      全局变量都有唯一的运行时存储器地址了。

    o 重定位节中的符号引用

      在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的
      运行时地址。为了执行这一步，链接器依赖于称为重定位条目（relocation entry）
      的可重定位目标模块中的数据结构。
        p461

当汇编器生成一个目标模块时，它并不知道数据和代码最终将存放在存储器中的什么位置。
它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何时汇编
器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件
合并成可执行文件时如何修改这个引用。
        p461

代码的重定位条目放在 .rel.text 中。已初始化数据的重定位条目放在 .rel.data 中。
        p461

重定位算法的伪代码：

foreach section s {
    foreach relocation entry {
        refptr = s + r.offset; /* ptr to reference to be relocated */

        /* Relocate a PC-relative reference */
        if (r.type == R_386_PC32) {
            refaddr = ADDR(s) + r.offset; /* ref's run-time address */
            *refptr = (unsigned)(ADDR(r.symbol) + *refptr - refaddr)
        }

        /* Relocate an absolute reference */
        if (r.type == R_386_32)
            *refptr = (unsigned)(ADDR(r.symbol) + *refptr)
    }
}

假设当运行时，链接器已经为每个节（用 ADDR(s) 表示）和每个符号都选择了运行时地址
（用 ADDR(r.symbol) 表示）。
        p462

通过调用某个驻留在存储器中称为加载器（loader）的操作系统代码来运行可执行文件。任
何 UNIX 程序都可以通过调用 execve 函数来调用加载器。

加载器将可执行目标文件中的代码和数据从磁盘拷贝到存储器中，然后通过跳转到程序的第
一条指令或入口段（entry point）来运行该程序。这个将程序拷贝到存储器并运行的过程
叫做加载（loading）。
        p466

当加载器运行时，它创建一个存储器映像。在可执行文件中段头部表的指导下，加载器将可
执行文件的相关内容拷贝到代码和数据段。接下来，加载器跳转到程序的入口点，也就是符
号 _start 的地址。在 _start 地址处的启动代码（startup code）是在目标文件 ctl1.o
中定义的，对所有的 C 程序都是一样的。
        p466

加载器实际上是如何工作的？

UNIX 系统中的每个程序都运行在一个进程上下文中，有自己的虚拟地址空间。当外壳运行
一个程序时，父外壳生成一个子进程，它是父进程的一个复制品。子进程通过 execve 系统
调用启动加载器。

加载器删除子进程现有的虚拟存储器段，并创建一组新的代码、数据、堆和栈段。新的栈和
堆段被初始化为零。通过将虚拟地址空间中的页映射到可执行文件的页大小的片（chunk），
新的代码和数据段被初始化为可执行文件的内容。

最后，加载器跳转到 _start 地址，它最终会调用应用程序的 main 函数。

除了一些头部信息，在加载过程中没有任何从磁盘到存储器的数据拷贝。直到 CPU 引用一
个被映射的虚拟页才会进行拷贝，此时，操作系统利用它的页面调度机制自动将页面从磁盘
传送到存储器。
        p467

静态库有一些明显的缺点。

静态库和所有的软件一样，需要定期维护和更新。如果应用程序员想要使用一个库的最新版
本，他们必须以某种方式了解到该库的更新情况，然后显式地将他们的程序与更新了的库重
新链接。

另一个问题是几乎每个 C 程序都使用标准的 I/O 函数，如 printf 和 scanf。在运行时，
这些函数的代码会被复制到每个运行进程的文本段中。在一个运行 50~100 个进程的典型系
统上，这将是对稀缺的存储器系统资源的极大浪费。
        p467

共享库（shared library）是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目
标模块，在运行时，可以加载到任意的存储器地址，并和一个在存储器中的程序链接起来。
这个过程称为动态链接（dynamic linking），是由一个佳作动态链接器（dynamic linker）
的程序来执行的。

共享库也称为共享目标（shared object），在 UNIX 系统中通常用 .so 后缀来表示。微软
的操作系统大量地利用了共享库，它们称为 DLL（动态链接库）。
        p467

共享库是以两种不同的方式来“共享”的。

    o 在任何给定的文件系统中，对于一个库只有一个 .so 文件

      所有引用该库的可执行目标文件共享这个 .so 文件中的代码和数据，而不是像静态
      库的内容那样被拷贝和嵌入到引用它们的可执行文件中

    o 在存储器中，一个共享库的 .text 节的一个副本可以被不同的正在运行的进程共享
        p468

unix> gcc -shared -fPIC -o libvector.so addvec.c multvec.c
unix> gcc -o p2 main2.c ./libvector.so

这样就创建了一个可执行文件 p2，而此文件的形式使得它在运行时可以和 libvector.so
链接。基本的思路是当创建可执行文件时，静态执行一些链接，然后在程序加载时，动态完
成链接过程。

认识到这一点很重要：此时，没有任何 libvector.so 的代码和数据真的被拷贝到可执行文
件 p2 中。反之，链接器拷贝了一些重定位和符号表信息，它们使得运行时可以解析对
libvector.so 中代码和数据的引用。

当加载器加载和运行可执行文件 p2 时，加载部分链接的可执行文件 p2。接着，它注意到
p2 包含一个 .interp 节，这个节包含动态链接器的路径名，动态链接器本身就是一个共享
目标（比如，在 Linux 系统上的 ld-linux.so）。加载器不再像它通常那样将控制传递给
应用，而是加载和运行这个动态链接器。

动态链接器通过执行下面的重定位完成链接任务：

    o 重定位 libc.so 的文本和数据到某个存储器段
    o 重定位 libvector.so 的文本和数据到另一个存储器段
    o 重定位 p2 中所有对 libc.so 和 libvector.so 定义的符号的引用

最后，动态链接器将控制传递到应用程序。从这个时刻开始，共享库的位置就固定了，并且
在程序执行的过程中都不会改变。
        p468

编译库代码，使得不需要链接器修改库代码就可以在任何地址加载和执行这些代码。这样的
代码叫做与位置无关的代码（Position-Independent Code, PIC）。用户对 GCC 使用
-fPIC 选项指示 GNU 编译系统生成 PIC 代码。
        p471

编译器通过运用以下这个有趣的事实来生成对全局变量的 PIC 引用：无论我们在存储器中
的何处加载一个目标模块（包括共享目标模块），数据段总是被分配成紧随在代码段后面。
因此，代码段中任何指令和数据段中任何变量之间的距离都是一个运行时常量，与代码段和
数据段的绝对存储器位置是无关的。

为了运用这个事实，编译器在数据段开始的地方创建了一个表，叫做全局偏移量表（Global
Offset Table, GOT）。在 GOT 中，每个被这个目标模块引用的全局数据对象都有一个条目。
编译器还为 GOT 中每个条目生成一个重定位记录。在加载时，动态链接器会重定位 GOT 中
的每个条目，使得它包含正确的绝对地址。每个引用全局数据的目标模块都有自己的 GOT。
        p471

PIC 代码有性能缺陷。每个全局变量的引用需要额外的 4 条指令，对每个运行时过程调用
需要额外的 3 条指令。
        p471~p472

延迟绑定（lazy binding），将过程地址的绑定推迟到第一次调用该过程时。

延迟绑定是通过两个数据结构之间简洁但又有些复杂的交互来实现的，这两个数据结构是：
GOT 和 PLT（过程连接表，Procedure Linkage Table）。如果一个目标模块调用定义在共
享库中的任何函数，那么它就有自己的 GOT 和 PLT。

GOT 是 .data 节的一部分，PLT 是 .text 节的一部分。
        p472
