第 8 章 异常控制流

从给处理器加电开始，直到断电为止，程序计数器假设一个值的序列

    a[0],a[1],...,a[n-1]

其中，每个 a[k] 是某个相应的指令 I[k] 的地址。每次从 a[k] 到 a[k+1] 的过渡称为控
制转移（control transfer）。这样的控制转移序列叫做处理器的控制流（flow of
control 或 control flow）。
        p480

现代系统通过使控制流发生突变来对系统状态做出反应。一般而言，我们把这些突变称为异
常控制流（Exceptional Control Flow, ECF）。异常控制流发生在计算机系统的各个层次。
        p480

作为程序员，理解 ECF 很重要，这有很多原因：

    o 帮助你理解重要的系统概念。ECF 是操作系统用来实现 I/O、进程和虚拟存储器的基
      本机制。在能够真正理解这些重要概念之前，你必须理解 ECF。

    o 帮助你理解应用程序是如何与操作系统交互的。应用程序通过一个叫做陷阱（trap）
      或者系统调用（system call）的 ECF 形式，向操作系统请求服务。比如，向磁盘写
      数据、从网络读取数据、创建一个新进程，以及终止当前进程，都是通过应用程序调
      用系统调用来实现的。理解基本的系统调用机制将帮助你理解是如何向应用出那个需
      提供这些服务的。

    o 帮助你编写有趣的新应用程序。操作系统为应用程序提供了强大的 ECF 机制，用来创
      建进程、等待进程终止、通知其他进程系统中的异常事件，以及检测和响应这些事件。
      如果你理解这些 ECF 机制，那么你就能用它们来编写诸如 UNIX 外壳和 Web 服务器
      之类的有趣程序了。

    o 帮助你理解并发。ECF 是计算机系统中实现并发的基本机制。中断应用程序、进程和
      线程（它们的执行在时间上是重叠的）执行的异常处理程序和中断应用程序执行的信
      号处理程序都是在运行中的并发的例子。理解 ECF 是理解并发的第一步。

    o 帮助你理解软件异常如何工作。像 C++ 和 Java 这样的语言通过 try、catch 以及
      throw 语句来提供软件异常机制。软件异常允许程序进行非本地跳转（违反通常的调
      用/返回栈规则的跳转）来响应错误情况。非本地跳转是一种应用层 ECF，在 C 中是
      通过setjmp() 和 longjmp() 函数提供的。理解这些低级函数将帮助你理解高级软件
      异常如何得以实现。
        p480

异常是异常控制流的一种形式，它一部分是由硬件实现的，一部分是由操作系统实现的。
        p481

在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做异常表（exception
table）的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件的
操作系统子程序（异常处理程序，exception handler）。

当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下情况中的一种：

    o 处理程序将控制返回给当前指令 I[curr]，即当事件发生时正在执行的指令
    o 处理程序将控制返回给 I[next]，即如果没有发生异常将会执行的下一条指令
    o 处理程序终止被中断的程序
        p481

系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号（exception number）。
其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核（操作系统常驻存储
器部分）的设计者分配的。前者的示例包括被零除、缺页、存储器访问违例、断点以及算术
溢出。后者的示例包括系统调用和来自外部 I/O 设备的信号。
        p481~p482

在系统启动时（当计算机重启或者加电时），操作系统分配和初始化一张称为异常表的跳转
表，使得条目 k 包含异常 k 的处理程序的地址。

在运行时（当系统在执行某个程序时），处理器检测到发生了一个事件，并且确定了相应的
异常号 k。随后，处理器触发异常，方法是执行间接过程调用，通过异常表的条目 k 转到
相应的处理程序。异常号是到异常表的索引，异常表的起始地址放在一个叫做异常表基址寄
存器（exception table base register）的特殊 CPU 寄存器里。
        p482

异常类似与过程调用，但是有一些重要的不同之处：

    o 过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常
      的类型，返回地址要么是当前指令（当事件发生时正在执行的指令），要么是下一条
      指令（如果事件不发生，将会在当前指令后执行的指令）

    o 处理器也把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始被中断的
      程序会需要这些状态。比如，一个 IA32 系统将包含当前条件吗和其他内容的
      EFLAGS寄存器压入栈中。

    o 如果控制从一个用户程序转移到内核，那么所有这些项目都被压到内核栈中，而不是
      压到用户栈中。

    o 异常处理程序运行在内核模式下，这意味着它们对所有的系统资源都有完全的访问权限
        p482

一旦硬件触发了异常，剩下的工作就是由异常处理程序在软件中完成。在处理程序处理完事
件之后，它通过执行一条特殊的“从中断返回”指令，可选地返回到被中断的程序，该指令
将适当的状态弹回到处理器的控制和数据寄存器中，如果异常中断的是一个用户程序，就将
状态恢复为用户模式，然后将控制返回给被中断的程序。
        p482

异常可以分为四类：中断（interrupt）、陷阱（trap）、故障（fault）和终止（abort）。

    o 中断 中断是异步发生的，是来自处理器外部的 I/O 设备的信号的结果

    o 陷阱 陷阱是有意的异常，是执行一条指令的结果。陷阱最重要的用途是在用户程序和
      内核之间提供一个像过程一样的接口，叫做系统调用。

    o 故障 故障是由错误情况引起的，他可能能够被故障处理程序修正。一个经典的故障
    示例是缺页异常。

    o 终止 终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如 DRAM 或者
      SRAM 位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。
        p482~p484

各种异常类型的术语是根据系统的不同而有所不同的。处理器宏体系结构
（macroarchitecture）规范通常会区分异步的“中断”和同步的“异常”，但是并没有提
供描述这些非常相似的概念的概括性的属于。为了避免不断地提供“异常和中断”以及“异
常或者中断”，我们用“异常”作为通用的术语，而且只有在必要时才区别异步异常（中断）
和同步异常（陷阱、故障和终止）。正如我们提到过的，对于每个系统而言，基本的概念都
是相同的，但是你应该意识到一些制造厂商的手册会用“异常”仅仅表示同步事件引起的控
制流的改变。
        p486

进程的经典定义就是：一个执行中的程序的实例。系统中的每个程序都是运行在某个进程的
上下文（context）中的。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在
存储器中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以
及打开文件描述符的集合。
        p487

进程提供给应用程序的关键抽象：

    o 一个独立的逻辑控制流，它提供一种假象，好像我们的程序独占地使用处理器
    o 一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用存储器系统
        p487

操作系统使用一种称为上下文切换（context switch）的较高层形式的异常控制流来实现多
任务。上下文切换机制是建立在较低层异常机制之上的。

内核为每个进程维持一个上下文。上下文就是内核重新启动一个被抢占的进程所需的状态。
它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、
状态寄存器、内核栈和各种内核数据结构，比如描绘地址空间的页表、包含有关当前进程信
息的进程表，以及包含进程已打开文件的信息的文件表。

在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程。
这种决定就叫做调度（schedule），是由内核中称为调度器（scheduler）的代码处理的。
当内核选择一个新的进程运行时，我们就说内核调度了这个进程。在内核调度了一个新的进
程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程。

上下文切换：
    o 保存当前进程的上下文
    o 恢复某个先前被抢占的进程被保存的上下文
    o 将控制传递给这个新恢复的进程
        p489~p490

高速缓存污染（pollution）和异常控制流

一般而言，硬件高速缓存存储器不能和诸如中断和上下文切换这样的异常控制流很好地交互。
如果当前进程被一个中断暂时中断，那么对于中断处理程序来说高速缓存是冷的（cold）
（译者注：“高速缓存是冷的”意思是程序所需要的数据都不在高速缓存中）。如果处理程
序从主存中访问了足够多的表项，那么当被中断的进程继续时，高速缓存对它来说也是冷的
了。在这种情况下，我们就说中断处理程序污染（pollute）了高速缓存。使用上下文切换
也会发生类似的现象。当一个进程在上下文切换后继续执行时，高速缓存对于应用程序而言
也是冷的，必须再次热身。
        p490

一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。每种信号类型都
对应于某种系统事件。
        p504~p505

传送一个信号到达目的进程是由两个不同步骤组成的：

    o 发送信号。内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目
      的进程。发送信号可以有如下原因：1）内核检测到一个系统事件，比如被零除错误或
      者子进程终止。2）一个进程调用了 kill 函数，显示要求内核发送一个信号给目的进
      程。一个进程可以发送信号给它自己。

    o 接收信号。当目的进程被内核强迫以某种方式对信号的发送做出反应时，目的进程就
      接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序
      （signal handler）的用户层函数捕获这个信号。

一个只发出而没有被接收的信号叫做待处理信号（pending signal）。在任何时刻，一种类
型至多只会有一个类型为 k 的待处理信号，那么任何接下来发送到这个进程的类型为 k 的
信号都不会排队等待，它们只是被简单地丢弃。

一个进程可以有选择性地阻塞接收某种信号。当一种信号被阻塞时，它仍可以被发送，但是
产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。

一个待处理信号最多只能被接收一次。内核为每个进程在 pending 位向量中维护着待处理
信号的集合，而在 blocked 位向量中维护着被阻塞的信号集合。只要传送了一个类型为 k
的信号，内核就会被设置 pending 中的第 k 位，而只要接收了一个类型为 k 的信号，内
核就会清除 pending 中的第 k 位。
        p505~p506

C 语言提供了一种用户级异常控制流形式，称为非本地跳转（nonlocal jump），它将控制
直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列。
非本地跳转是通过 setjmp() 和 longjmp() 函数来提供的。

非本地跳转的一个重要应用就是允许从一个深层嵌套的函数调用中立即返回，通常是由检测
到某个错误情况引起的。如果在一个深层嵌套的函数调用中发现了一个错误，我们可以使用
非本地跳转直接返回到一个普通的本地化的错误处理程序，而不是费力地解开调用栈。

非本地跳转的另一个重要应用是使一个信号处理程序分支到一个特殊的代码位置，而不是返
回到被信号到达中断了的指令的位置。
        p521~p522

Linux 系统提供了大量的监控和操作进程的有用工具：

    o strace

      打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。对于好奇的学生
      而言，这是一个令人着迷的工具。用 -static 编译你的程序，能得到一个更干净的、
      不带有大量与共享库相关的输出的轨迹。

    o ps

      列出当前系统中的进程（包括僵死进程）

    o top

      打印出关于当前进程资源使用的信息

    o pmap

      显示进程的存储器映射
        p524
